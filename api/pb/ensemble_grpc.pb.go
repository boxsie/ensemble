// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v3.19.6
// source: ensemble.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EnsembleService_GetIdentity_FullMethodName      = "/ensemble.api.EnsembleService/GetIdentity"
	EnsembleService_GetStatus_FullMethodName        = "/ensemble.api.EnsembleService/GetStatus"
	EnsembleService_ListContacts_FullMethodName     = "/ensemble.api.EnsembleService/ListContacts"
	EnsembleService_AddContact_FullMethodName       = "/ensemble.api.EnsembleService/AddContact"
	EnsembleService_RemoveContact_FullMethodName    = "/ensemble.api.EnsembleService/RemoveContact"
	EnsembleService_Connect_FullMethodName          = "/ensemble.api.EnsembleService/Connect"
	EnsembleService_AcceptConnection_FullMethodName = "/ensemble.api.EnsembleService/AcceptConnection"
	EnsembleService_RejectConnection_FullMethodName = "/ensemble.api.EnsembleService/RejectConnection"
	EnsembleService_SendMessage_FullMethodName      = "/ensemble.api.EnsembleService/SendMessage"
	EnsembleService_SendFile_FullMethodName         = "/ensemble.api.EnsembleService/SendFile"
	EnsembleService_AcceptFile_FullMethodName       = "/ensemble.api.EnsembleService/AcceptFile"
	EnsembleService_RejectFile_FullMethodName       = "/ensemble.api.EnsembleService/RejectFile"
	EnsembleService_Subscribe_FullMethodName        = "/ensemble.api.EnsembleService/Subscribe"
)

// EnsembleServiceClient is the client API for EnsembleService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EnsembleServiceClient interface {
	// Identity
	GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error)
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// Contacts
	ListContacts(ctx context.Context, in *ListContactsRequest, opts ...grpc.CallOption) (*ListContactsResponse, error)
	AddContact(ctx context.Context, in *AddContactRequest, opts ...grpc.CallOption) (*AddContactResponse, error)
	RemoveContact(ctx context.Context, in *RemoveContactRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error)
	// Connection
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error)
	AcceptConnection(ctx context.Context, in *AcceptConnectionRequest, opts ...grpc.CallOption) (*AcceptConnectionResponse, error)
	RejectConnection(ctx context.Context, in *RejectConnectionRequest, opts ...grpc.CallOption) (*RejectConnectionResponse, error)
	// Chat
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// File transfer
	SendFile(ctx context.Context, in *SendFileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransferProgress], error)
	AcceptFile(ctx context.Context, in *AcceptFileRequest, opts ...grpc.CallOption) (*AcceptFileResponse, error)
	RejectFile(ctx context.Context, in *RejectFileRequest, opts ...grpc.CallOption) (*RejectFileResponse, error)
	// Events
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DaemonEvent], error)
}

type ensembleServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEnsembleServiceClient(cc grpc.ClientConnInterface) EnsembleServiceClient {
	return &ensembleServiceClient{cc}
}

func (c *ensembleServiceClient) GetIdentity(ctx context.Context, in *GetIdentityRequest, opts ...grpc.CallOption) (*GetIdentityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetIdentityResponse)
	err := c.cc.Invoke(ctx, EnsembleService_GetIdentity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, EnsembleService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) ListContacts(ctx context.Context, in *ListContactsRequest, opts ...grpc.CallOption) (*ListContactsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListContactsResponse)
	err := c.cc.Invoke(ctx, EnsembleService_ListContacts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) AddContact(ctx context.Context, in *AddContactRequest, opts ...grpc.CallOption) (*AddContactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddContactResponse)
	err := c.cc.Invoke(ctx, EnsembleService_AddContact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) RemoveContact(ctx context.Context, in *RemoveContactRequest, opts ...grpc.CallOption) (*RemoveContactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RemoveContactResponse)
	err := c.cc.Invoke(ctx, EnsembleService_RemoveContact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConnectResponse)
	err := c.cc.Invoke(ctx, EnsembleService_Connect_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) AcceptConnection(ctx context.Context, in *AcceptConnectionRequest, opts ...grpc.CallOption) (*AcceptConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptConnectionResponse)
	err := c.cc.Invoke(ctx, EnsembleService_AcceptConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) RejectConnection(ctx context.Context, in *RejectConnectionRequest, opts ...grpc.CallOption) (*RejectConnectionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectConnectionResponse)
	err := c.cc.Invoke(ctx, EnsembleService_RejectConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, EnsembleService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) SendFile(ctx context.Context, in *SendFileRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransferProgress], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EnsembleService_ServiceDesc.Streams[0], EnsembleService_SendFile_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SendFileRequest, TransferProgress]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnsembleService_SendFileClient = grpc.ServerStreamingClient[TransferProgress]

func (c *ensembleServiceClient) AcceptFile(ctx context.Context, in *AcceptFileRequest, opts ...grpc.CallOption) (*AcceptFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptFileResponse)
	err := c.cc.Invoke(ctx, EnsembleService_AcceptFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) RejectFile(ctx context.Context, in *RejectFileRequest, opts ...grpc.CallOption) (*RejectFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RejectFileResponse)
	err := c.cc.Invoke(ctx, EnsembleService_RejectFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ensembleServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DaemonEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EnsembleService_ServiceDesc.Streams[1], EnsembleService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, DaemonEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnsembleService_SubscribeClient = grpc.ServerStreamingClient[DaemonEvent]

// EnsembleServiceServer is the server API for EnsembleService service.
// All implementations must embed UnimplementedEnsembleServiceServer
// for forward compatibility.
type EnsembleServiceServer interface {
	// Identity
	GetIdentity(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error)
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// Contacts
	ListContacts(context.Context, *ListContactsRequest) (*ListContactsResponse, error)
	AddContact(context.Context, *AddContactRequest) (*AddContactResponse, error)
	RemoveContact(context.Context, *RemoveContactRequest) (*RemoveContactResponse, error)
	// Connection
	Connect(context.Context, *ConnectRequest) (*ConnectResponse, error)
	AcceptConnection(context.Context, *AcceptConnectionRequest) (*AcceptConnectionResponse, error)
	RejectConnection(context.Context, *RejectConnectionRequest) (*RejectConnectionResponse, error)
	// Chat
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	// File transfer
	SendFile(*SendFileRequest, grpc.ServerStreamingServer[TransferProgress]) error
	AcceptFile(context.Context, *AcceptFileRequest) (*AcceptFileResponse, error)
	RejectFile(context.Context, *RejectFileRequest) (*RejectFileResponse, error)
	// Events
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[DaemonEvent]) error
	mustEmbedUnimplementedEnsembleServiceServer()
}

// UnimplementedEnsembleServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEnsembleServiceServer struct{}

func (UnimplementedEnsembleServiceServer) GetIdentity(context.Context, *GetIdentityRequest) (*GetIdentityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetIdentity not implemented")
}
func (UnimplementedEnsembleServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedEnsembleServiceServer) ListContacts(context.Context, *ListContactsRequest) (*ListContactsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListContacts not implemented")
}
func (UnimplementedEnsembleServiceServer) AddContact(context.Context, *AddContactRequest) (*AddContactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AddContact not implemented")
}
func (UnimplementedEnsembleServiceServer) RemoveContact(context.Context, *RemoveContactRequest) (*RemoveContactResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RemoveContact not implemented")
}
func (UnimplementedEnsembleServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedEnsembleServiceServer) AcceptConnection(context.Context, *AcceptConnectionRequest) (*AcceptConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptConnection not implemented")
}
func (UnimplementedEnsembleServiceServer) RejectConnection(context.Context, *RejectConnectionRequest) (*RejectConnectionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RejectConnection not implemented")
}
func (UnimplementedEnsembleServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedEnsembleServiceServer) SendFile(*SendFileRequest, grpc.ServerStreamingServer[TransferProgress]) error {
	return status.Error(codes.Unimplemented, "method SendFile not implemented")
}
func (UnimplementedEnsembleServiceServer) AcceptFile(context.Context, *AcceptFileRequest) (*AcceptFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptFile not implemented")
}
func (UnimplementedEnsembleServiceServer) RejectFile(context.Context, *RejectFileRequest) (*RejectFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RejectFile not implemented")
}
func (UnimplementedEnsembleServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[DaemonEvent]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEnsembleServiceServer) mustEmbedUnimplementedEnsembleServiceServer() {}
func (UnimplementedEnsembleServiceServer) testEmbeddedByValue()                         {}

// UnsafeEnsembleServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EnsembleServiceServer will
// result in compilation errors.
type UnsafeEnsembleServiceServer interface {
	mustEmbedUnimplementedEnsembleServiceServer()
}

func RegisterEnsembleServiceServer(s grpc.ServiceRegistrar, srv EnsembleServiceServer) {
	// If the following call panics, it indicates UnimplementedEnsembleServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EnsembleService_ServiceDesc, srv)
}

func _EnsembleService_GetIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).GetIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_GetIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).GetIdentity(ctx, req.(*GetIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_ListContacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListContactsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).ListContacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_ListContacts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).ListContacts(ctx, req.(*ListContactsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_AddContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).AddContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_AddContact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).AddContact(ctx, req.(*AddContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_RemoveContact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).RemoveContact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_RemoveContact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).RemoveContact(ctx, req.(*RemoveContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_AcceptConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).AcceptConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_AcceptConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).AcceptConnection(ctx, req.(*AcceptConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_RejectConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).RejectConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_RejectConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).RejectConnection(ctx, req.(*RejectConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_SendFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SendFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnsembleServiceServer).SendFile(m, &grpc.GenericServerStream[SendFileRequest, TransferProgress]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnsembleService_SendFileServer = grpc.ServerStreamingServer[TransferProgress]

func _EnsembleService_AcceptFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).AcceptFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_AcceptFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).AcceptFile(ctx, req.(*AcceptFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_RejectFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EnsembleServiceServer).RejectFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EnsembleService_RejectFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EnsembleServiceServer).RejectFile(ctx, req.(*RejectFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EnsembleService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EnsembleServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, DaemonEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EnsembleService_SubscribeServer = grpc.ServerStreamingServer[DaemonEvent]

// EnsembleService_ServiceDesc is the grpc.ServiceDesc for EnsembleService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EnsembleService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "ensemble.api.EnsembleService",
	HandlerType: (*EnsembleServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetIdentity",
			Handler:    _EnsembleService_GetIdentity_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _EnsembleService_GetStatus_Handler,
		},
		{
			MethodName: "ListContacts",
			Handler:    _EnsembleService_ListContacts_Handler,
		},
		{
			MethodName: "AddContact",
			Handler:    _EnsembleService_AddContact_Handler,
		},
		{
			MethodName: "RemoveContact",
			Handler:    _EnsembleService_RemoveContact_Handler,
		},
		{
			MethodName: "Connect",
			Handler:    _EnsembleService_Connect_Handler,
		},
		{
			MethodName: "AcceptConnection",
			Handler:    _EnsembleService_AcceptConnection_Handler,
		},
		{
			MethodName: "RejectConnection",
			Handler:    _EnsembleService_RejectConnection_Handler,
		},
		{
			MethodName: "SendMessage",
			Handler:    _EnsembleService_SendMessage_Handler,
		},
		{
			MethodName: "AcceptFile",
			Handler:    _EnsembleService_AcceptFile_Handler,
		},
		{
			MethodName: "RejectFile",
			Handler:    _EnsembleService_RejectFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendFile",
			Handler:       _EnsembleService_SendFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _EnsembleService_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "ensemble.proto",
}
