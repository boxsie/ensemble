// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.19.6
// source: messages.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type MessageType int32

const (
	MessageType_MESSAGE_TYPE_UNSPECIFIED MessageType = 0
	// Signaling (3-step handshake)
	MessageType_CONN_REQUEST  MessageType = 1 // step 1: addresses + nonce (no public keys)
	MessageType_CONN_RESPONSE MessageType = 2 // step 2: responder identity proof (if accepted)
	MessageType_CONN_CONFIRM  MessageType = 3 // step 3: initiator identity proof
	MessageType_IP_EXCHANGE   MessageType = 4 // post-handshake: direct connection addresses
	// Chat
	MessageType_CHAT_TEXT   MessageType = 10
	MessageType_CHAT_ACK    MessageType = 11
	MessageType_CHAT_TYPING MessageType = 12
	// File transfer
	MessageType_FILE_OFFER     MessageType = 20
	MessageType_FILE_ACCEPT    MessageType = 21
	MessageType_FILE_REJECT    MessageType = 22
	MessageType_FILE_CHUNK     MessageType = 23
	MessageType_FILE_CHUNK_ACK MessageType = 24
	MessageType_FILE_COMPLETE  MessageType = 25
	MessageType_FILE_CANCEL    MessageType = 26
	// DHT
	MessageType_DHT_FIND_NODE     MessageType = 30
	MessageType_DHT_NODE_RESPONSE MessageType = 31
	MessageType_DHT_PUT_RECORD    MessageType = 32
	// Presence
	MessageType_PING MessageType = 40
	MessageType_PONG MessageType = 41
)

// Enum value maps for MessageType.
var (
	MessageType_name = map[int32]string{
		0:  "MESSAGE_TYPE_UNSPECIFIED",
		1:  "CONN_REQUEST",
		2:  "CONN_RESPONSE",
		3:  "CONN_CONFIRM",
		4:  "IP_EXCHANGE",
		10: "CHAT_TEXT",
		11: "CHAT_ACK",
		12: "CHAT_TYPING",
		20: "FILE_OFFER",
		21: "FILE_ACCEPT",
		22: "FILE_REJECT",
		23: "FILE_CHUNK",
		24: "FILE_CHUNK_ACK",
		25: "FILE_COMPLETE",
		26: "FILE_CANCEL",
		30: "DHT_FIND_NODE",
		31: "DHT_NODE_RESPONSE",
		32: "DHT_PUT_RECORD",
		40: "PING",
		41: "PONG",
	}
	MessageType_value = map[string]int32{
		"MESSAGE_TYPE_UNSPECIFIED": 0,
		"CONN_REQUEST":             1,
		"CONN_RESPONSE":            2,
		"CONN_CONFIRM":             3,
		"IP_EXCHANGE":              4,
		"CHAT_TEXT":                10,
		"CHAT_ACK":                 11,
		"CHAT_TYPING":              12,
		"FILE_OFFER":               20,
		"FILE_ACCEPT":              21,
		"FILE_REJECT":              22,
		"FILE_CHUNK":               23,
		"FILE_CHUNK_ACK":           24,
		"FILE_COMPLETE":            25,
		"FILE_CANCEL":              26,
		"DHT_FIND_NODE":            30,
		"DHT_NODE_RESPONSE":        31,
		"DHT_PUT_RECORD":           32,
		"PING":                     40,
		"PONG":                     41,
	}
)

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageType) Descriptor() protoreflect.EnumDescriptor {
	return file_messages_proto_enumTypes[0].Descriptor()
}

func (MessageType) Type() protoreflect.EnumType {
	return &file_messages_proto_enumTypes[0]
}

func (x MessageType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageType.Descriptor instead.
func (MessageType) EnumDescriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{0}
}

type Envelope struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          MessageType            `protobuf:"varint,1,opt,name=type,proto3,enum=ensemble.protocol.MessageType" json:"type,omitempty"`
	Payload       []byte                 `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Timestamp     int64                  `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`        // Unix millis
	PubKey        []byte                 `protobuf:"bytes,4,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"` // sender's Ed25519 public key
	Signature     []byte                 `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`         // Ed25519 signature over (type || payload || timestamp)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Envelope) Reset() {
	*x = Envelope{}
	mi := &file_messages_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Envelope) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Envelope) ProtoMessage() {}

func (x *Envelope) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Envelope.ProtoReflect.Descriptor instead.
func (*Envelope) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{0}
}

func (x *Envelope) GetType() MessageType {
	if x != nil {
		return x.Type
	}
	return MessageType_MESSAGE_TYPE_UNSPECIFIED
}

func (x *Envelope) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Envelope) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

func (x *Envelope) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *Envelope) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type ConnRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	FromAddress   string                 `protobuf:"bytes,1,opt,name=from_address,json=fromAddress,proto3" json:"from_address,omitempty"`       // initiator's ensemble address (hash, quantum-safe)
	TargetAddress string                 `protobuf:"bytes,2,opt,name=target_address,json=targetAddress,proto3" json:"target_address,omitempty"` // address of the peer we're trying to reach
	Nonce         []byte                 `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce,omitempty"`                                      // 32-byte random challenge
	Timestamp     int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                             // Unix millis, for freshness check
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnRequest) Reset() {
	*x = ConnRequest{}
	mi := &file_messages_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnRequest) ProtoMessage() {}

func (x *ConnRequest) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnRequest.ProtoReflect.Descriptor instead.
func (*ConnRequest) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{1}
}

func (x *ConnRequest) GetFromAddress() string {
	if x != nil {
		return x.FromAddress
	}
	return ""
}

func (x *ConnRequest) GetTargetAddress() string {
	if x != nil {
		return x.TargetAddress
	}
	return ""
}

func (x *ConnRequest) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *ConnRequest) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type ConnResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Accepted      bool                   `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`          // false = rejected (pub_key/signature empty)
	PubKey        []byte                 `protobuf:"bytes,2,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"` // responder's Ed25519 public key (only if accepted)
	Signature     []byte                 `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`         // sign(request_nonce) — proves ownership of target_address
	Nonce         []byte                 `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`                 // responder's challenge for initiator
	Reason        string                 `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`               // rejection reason (if !accepted)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnResponse) Reset() {
	*x = ConnResponse{}
	mi := &file_messages_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnResponse) ProtoMessage() {}

func (x *ConnResponse) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnResponse.ProtoReflect.Descriptor instead.
func (*ConnResponse) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{2}
}

func (x *ConnResponse) GetAccepted() bool {
	if x != nil {
		return x.Accepted
	}
	return false
}

func (x *ConnResponse) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *ConnResponse) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *ConnResponse) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *ConnResponse) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type ConnConfirm struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PubKey        []byte                 `protobuf:"bytes,1,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"` // initiator's Ed25519 public key
	Signature     []byte                 `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`         // sign(response_nonce) — proves ownership of from_address
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnConfirm) Reset() {
	*x = ConnConfirm{}
	mi := &file_messages_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnConfirm) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnConfirm) ProtoMessage() {}

func (x *ConnConfirm) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnConfirm.ProtoReflect.Descriptor instead.
func (*ConnConfirm) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{3}
}

func (x *ConnConfirm) GetPubKey() []byte {
	if x != nil {
		return x.PubKey
	}
	return nil
}

func (x *ConnConfirm) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type IPExchangeMsg struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Addrs         []string               `protobuf:"bytes,1,rep,name=addrs,proto3" json:"addrs,omitempty"` // multiaddrs for direct connection
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IPExchangeMsg) Reset() {
	*x = IPExchangeMsg{}
	mi := &file_messages_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IPExchangeMsg) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IPExchangeMsg) ProtoMessage() {}

func (x *IPExchangeMsg) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IPExchangeMsg.ProtoReflect.Descriptor instead.
func (*IPExchangeMsg) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{4}
}

func (x *IPExchangeMsg) GetAddrs() []string {
	if x != nil {
		return x.Addrs
	}
	return nil
}

type ChatText struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Id            string                 `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"` // unique message ID
	Text          string                 `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatText) Reset() {
	*x = ChatText{}
	mi := &file_messages_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatText) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatText) ProtoMessage() {}

func (x *ChatText) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatText.ProtoReflect.Descriptor instead.
func (*ChatText) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{5}
}

func (x *ChatText) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ChatText) GetText() string {
	if x != nil {
		return x.Text
	}
	return ""
}

type ChatAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	MessageId     string                 `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatAck) Reset() {
	*x = ChatAck{}
	mi := &file_messages_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatAck) ProtoMessage() {}

func (x *ChatAck) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatAck.ProtoReflect.Descriptor instead.
func (*ChatAck) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{6}
}

func (x *ChatAck) GetMessageId() string {
	if x != nil {
		return x.MessageId
	}
	return ""
}

type ChatTyping struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChatTyping) Reset() {
	*x = ChatTyping{}
	mi := &file_messages_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChatTyping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChatTyping) ProtoMessage() {}

func (x *ChatTyping) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChatTyping.ProtoReflect.Descriptor instead.
func (*ChatTyping) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{7}
}

type FileOffer struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	Filename      string                 `protobuf:"bytes,2,opt,name=filename,proto3" json:"filename,omitempty"`
	Size          uint64                 `protobuf:"varint,3,opt,name=size,proto3" json:"size,omitempty"`
	RootHash      []byte                 `protobuf:"bytes,4,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"` // Merkle root
	ChunkSize     uint32                 `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize,proto3" json:"chunk_size,omitempty"`
	ChunkCount    uint32                 `protobuf:"varint,6,opt,name=chunk_count,json=chunkCount,proto3" json:"chunk_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileOffer) Reset() {
	*x = FileOffer{}
	mi := &file_messages_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileOffer) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileOffer) ProtoMessage() {}

func (x *FileOffer) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileOffer.ProtoReflect.Descriptor instead.
func (*FileOffer) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{8}
}

func (x *FileOffer) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FileOffer) GetFilename() string {
	if x != nil {
		return x.Filename
	}
	return ""
}

func (x *FileOffer) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *FileOffer) GetRootHash() []byte {
	if x != nil {
		return x.RootHash
	}
	return nil
}

func (x *FileOffer) GetChunkSize() uint32 {
	if x != nil {
		return x.ChunkSize
	}
	return 0
}

func (x *FileOffer) GetChunkCount() uint32 {
	if x != nil {
		return x.ChunkCount
	}
	return 0
}

type FileAccept struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileAccept) Reset() {
	*x = FileAccept{}
	mi := &file_messages_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileAccept) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileAccept) ProtoMessage() {}

func (x *FileAccept) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileAccept.ProtoReflect.Descriptor instead.
func (*FileAccept) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{9}
}

func (x *FileAccept) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

type FileReject struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileReject) Reset() {
	*x = FileReject{}
	mi := &file_messages_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileReject) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileReject) ProtoMessage() {}

func (x *FileReject) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileReject.ProtoReflect.Descriptor instead.
func (*FileReject) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{10}
}

func (x *FileReject) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FileReject) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type FileChunk struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	Index         uint32                 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Data          []byte                 `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	Hash          []byte                 `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`   // SHA-256 of this chunk
	Proof         [][]byte               `protobuf:"bytes,5,rep,name=proof,proto3" json:"proof,omitempty"` // Merkle proof (sibling hashes, leaf→root)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileChunk) Reset() {
	*x = FileChunk{}
	mi := &file_messages_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileChunk) ProtoMessage() {}

func (x *FileChunk) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileChunk.ProtoReflect.Descriptor instead.
func (*FileChunk) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{11}
}

func (x *FileChunk) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FileChunk) GetIndex() uint32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *FileChunk) GetData() []byte {
	if x != nil {
		return x.Data
	}
	return nil
}

func (x *FileChunk) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *FileChunk) GetProof() [][]byte {
	if x != nil {
		return x.Proof
	}
	return nil
}

type FileChunkAck struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	Index         uint32                 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Valid         bool                   `protobuf:"varint,3,opt,name=valid,proto3" json:"valid,omitempty"` // true = chunk verified, false = needs retransmit
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileChunkAck) Reset() {
	*x = FileChunkAck{}
	mi := &file_messages_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileChunkAck) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileChunkAck) ProtoMessage() {}

func (x *FileChunkAck) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileChunkAck.ProtoReflect.Descriptor instead.
func (*FileChunkAck) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{12}
}

func (x *FileChunkAck) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FileChunkAck) GetIndex() uint32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *FileChunkAck) GetValid() bool {
	if x != nil {
		return x.Valid
	}
	return false
}

type FileComplete struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileComplete) Reset() {
	*x = FileComplete{}
	mi := &file_messages_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileComplete) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileComplete) ProtoMessage() {}

func (x *FileComplete) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileComplete.ProtoReflect.Descriptor instead.
func (*FileComplete) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{13}
}

func (x *FileComplete) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

type FileCancel struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	TransferId    string                 `protobuf:"bytes,1,opt,name=transfer_id,json=transferId,proto3" json:"transfer_id,omitempty"`
	Reason        string                 `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileCancel) Reset() {
	*x = FileCancel{}
	mi := &file_messages_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileCancel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileCancel) ProtoMessage() {}

func (x *FileCancel) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileCancel.ProtoReflect.Descriptor instead.
func (*FileCancel) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{14}
}

func (x *FileCancel) GetTransferId() string {
	if x != nil {
		return x.TransferId
	}
	return ""
}

func (x *FileCancel) GetReason() string {
	if x != nil {
		return x.Reason
	}
	return ""
}

type DHTFindNode struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Target        []byte                 `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"` // 20-byte node ID (RIPEMD-160 hash) to find
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DHTFindNode) Reset() {
	*x = DHTFindNode{}
	mi := &file_messages_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DHTFindNode) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DHTFindNode) ProtoMessage() {}

func (x *DHTFindNode) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DHTFindNode.ProtoReflect.Descriptor instead.
func (*DHTFindNode) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{15}
}

func (x *DHTFindNode) GetTarget() []byte {
	if x != nil {
		return x.Target
	}
	return nil
}

type DHTNodeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Peers         []*PeerRecord          `protobuf:"bytes,1,rep,name=peers,proto3" json:"peers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DHTNodeResponse) Reset() {
	*x = DHTNodeResponse{}
	mi := &file_messages_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DHTNodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DHTNodeResponse) ProtoMessage() {}

func (x *DHTNodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DHTNodeResponse.ProtoReflect.Descriptor instead.
func (*DHTNodeResponse) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{16}
}

func (x *DHTNodeResponse) GetPeers() []*PeerRecord {
	if x != nil {
		return x.Peers
	}
	return nil
}

type DHTPutRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Record        *PeerRecord            `protobuf:"bytes,1,opt,name=record,proto3" json:"record,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DHTPutRecord) Reset() {
	*x = DHTPutRecord{}
	mi := &file_messages_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DHTPutRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DHTPutRecord) ProtoMessage() {}

func (x *DHTPutRecord) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DHTPutRecord.ProtoReflect.Descriptor instead.
func (*DHTPutRecord) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{17}
}

func (x *DHTPutRecord) GetRecord() *PeerRecord {
	if x != nil {
		return x.Record
	}
	return nil
}

// PeerRecord is hash-only by design — no public keys broadcast to the network.
// This prevents quantum key harvesting. Trust is established at the signaling layer.
type PeerRecord struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeId        []byte                 `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`                   // 20-byte RIPEMD-160(SHA-256(pubkey))
	Address       string                 `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`                               // ensemble Base58Check address (hash-based, quantum-safe)
	OnionAddress  string                 `protobuf:"bytes,3,opt,name=onion_address,json=onionAddress,proto3" json:"onion_address,omitempty"` // .onion address for signaling
	Timestamp     int64                  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`                          // Unix millis, for expiry (24h)
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PeerRecord) Reset() {
	*x = PeerRecord{}
	mi := &file_messages_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PeerRecord) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PeerRecord) ProtoMessage() {}

func (x *PeerRecord) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PeerRecord.ProtoReflect.Descriptor instead.
func (*PeerRecord) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{18}
}

func (x *PeerRecord) GetNodeId() []byte {
	if x != nil {
		return x.NodeId
	}
	return nil
}

func (x *PeerRecord) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

func (x *PeerRecord) GetOnionAddress() string {
	if x != nil {
		return x.OnionAddress
	}
	return ""
}

func (x *PeerRecord) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type Ping struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Timestamp     int64                  `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Ping) Reset() {
	*x = Ping{}
	mi := &file_messages_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Ping) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Ping) ProtoMessage() {}

func (x *Ping) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Ping.ProtoReflect.Descriptor instead.
func (*Ping) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{19}
}

func (x *Ping) GetTimestamp() int64 {
	if x != nil {
		return x.Timestamp
	}
	return 0
}

type Pong struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	EchoTimestamp int64                  `protobuf:"varint,1,opt,name=echo_timestamp,json=echoTimestamp,proto3" json:"echo_timestamp,omitempty"` // echo back the ping's timestamp
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Pong) Reset() {
	*x = Pong{}
	mi := &file_messages_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Pong) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Pong) ProtoMessage() {}

func (x *Pong) ProtoReflect() protoreflect.Message {
	mi := &file_messages_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Pong.ProtoReflect.Descriptor instead.
func (*Pong) Descriptor() ([]byte, []int) {
	return file_messages_proto_rawDescGZIP(), []int{20}
}

func (x *Pong) GetEchoTimestamp() int64 {
	if x != nil {
		return x.EchoTimestamp
	}
	return 0
}

var File_messages_proto protoreflect.FileDescriptor

const file_messages_proto_rawDesc = "" +
	"\n" +
	"\x0emessages.proto\x12\x11ensemble.protocol\"\xad\x01\n" +
	"\bEnvelope\x122\n" +
	"\x04type\x18\x01 \x01(\x0e2\x1e.ensemble.protocol.MessageTypeR\x04type\x12\x18\n" +
	"\apayload\x18\x02 \x01(\fR\apayload\x12\x1c\n" +
	"\ttimestamp\x18\x03 \x01(\x03R\ttimestamp\x12\x17\n" +
	"\apub_key\x18\x04 \x01(\fR\x06pubKey\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\fR\tsignature\"\x8b\x01\n" +
	"\vConnRequest\x12!\n" +
	"\ffrom_address\x18\x01 \x01(\tR\vfromAddress\x12%\n" +
	"\x0etarget_address\x18\x02 \x01(\tR\rtargetAddress\x12\x14\n" +
	"\x05nonce\x18\x03 \x01(\fR\x05nonce\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\"\x8f\x01\n" +
	"\fConnResponse\x12\x1a\n" +
	"\baccepted\x18\x01 \x01(\bR\baccepted\x12\x17\n" +
	"\apub_key\x18\x02 \x01(\fR\x06pubKey\x12\x1c\n" +
	"\tsignature\x18\x03 \x01(\fR\tsignature\x12\x14\n" +
	"\x05nonce\x18\x04 \x01(\fR\x05nonce\x12\x16\n" +
	"\x06reason\x18\x05 \x01(\tR\x06reason\"D\n" +
	"\vConnConfirm\x12\x17\n" +
	"\apub_key\x18\x01 \x01(\fR\x06pubKey\x12\x1c\n" +
	"\tsignature\x18\x02 \x01(\fR\tsignature\"%\n" +
	"\rIPExchangeMsg\x12\x14\n" +
	"\x05addrs\x18\x01 \x03(\tR\x05addrs\".\n" +
	"\bChatText\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12\x12\n" +
	"\x04text\x18\x02 \x01(\tR\x04text\"(\n" +
	"\aChatAck\x12\x1d\n" +
	"\n" +
	"message_id\x18\x01 \x01(\tR\tmessageId\"\f\n" +
	"\n" +
	"ChatTyping\"\xb9\x01\n" +
	"\tFileOffer\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12\x1a\n" +
	"\bfilename\x18\x02 \x01(\tR\bfilename\x12\x12\n" +
	"\x04size\x18\x03 \x01(\x04R\x04size\x12\x1b\n" +
	"\troot_hash\x18\x04 \x01(\fR\brootHash\x12\x1d\n" +
	"\n" +
	"chunk_size\x18\x05 \x01(\rR\tchunkSize\x12\x1f\n" +
	"\vchunk_count\x18\x06 \x01(\rR\n" +
	"chunkCount\"-\n" +
	"\n" +
	"FileAccept\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\"E\n" +
	"\n" +
	"FileReject\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"\x80\x01\n" +
	"\tFileChunk\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12\x14\n" +
	"\x05index\x18\x02 \x01(\rR\x05index\x12\x12\n" +
	"\x04data\x18\x03 \x01(\fR\x04data\x12\x12\n" +
	"\x04hash\x18\x04 \x01(\fR\x04hash\x12\x14\n" +
	"\x05proof\x18\x05 \x03(\fR\x05proof\"[\n" +
	"\fFileChunkAck\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12\x14\n" +
	"\x05index\x18\x02 \x01(\rR\x05index\x12\x14\n" +
	"\x05valid\x18\x03 \x01(\bR\x05valid\"/\n" +
	"\fFileComplete\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\"E\n" +
	"\n" +
	"FileCancel\x12\x1f\n" +
	"\vtransfer_id\x18\x01 \x01(\tR\n" +
	"transferId\x12\x16\n" +
	"\x06reason\x18\x02 \x01(\tR\x06reason\"%\n" +
	"\vDHTFindNode\x12\x16\n" +
	"\x06target\x18\x01 \x01(\fR\x06target\"F\n" +
	"\x0fDHTNodeResponse\x123\n" +
	"\x05peers\x18\x01 \x03(\v2\x1d.ensemble.protocol.PeerRecordR\x05peers\"E\n" +
	"\fDHTPutRecord\x125\n" +
	"\x06record\x18\x01 \x01(\v2\x1d.ensemble.protocol.PeerRecordR\x06record\"\x82\x01\n" +
	"\n" +
	"PeerRecord\x12\x17\n" +
	"\anode_id\x18\x01 \x01(\fR\x06nodeId\x12\x18\n" +
	"\aaddress\x18\x02 \x01(\tR\aaddress\x12#\n" +
	"\ronion_address\x18\x03 \x01(\tR\fonionAddress\x12\x1c\n" +
	"\ttimestamp\x18\x04 \x01(\x03R\ttimestamp\"$\n" +
	"\x04Ping\x12\x1c\n" +
	"\ttimestamp\x18\x01 \x01(\x03R\ttimestamp\"-\n" +
	"\x04Pong\x12%\n" +
	"\x0eecho_timestamp\x18\x01 \x01(\x03R\rechoTimestamp*\xed\x02\n" +
	"\vMessageType\x12\x1c\n" +
	"\x18MESSAGE_TYPE_UNSPECIFIED\x10\x00\x12\x10\n" +
	"\fCONN_REQUEST\x10\x01\x12\x11\n" +
	"\rCONN_RESPONSE\x10\x02\x12\x10\n" +
	"\fCONN_CONFIRM\x10\x03\x12\x0f\n" +
	"\vIP_EXCHANGE\x10\x04\x12\r\n" +
	"\tCHAT_TEXT\x10\n" +
	"\x12\f\n" +
	"\bCHAT_ACK\x10\v\x12\x0f\n" +
	"\vCHAT_TYPING\x10\f\x12\x0e\n" +
	"\n" +
	"FILE_OFFER\x10\x14\x12\x0f\n" +
	"\vFILE_ACCEPT\x10\x15\x12\x0f\n" +
	"\vFILE_REJECT\x10\x16\x12\x0e\n" +
	"\n" +
	"FILE_CHUNK\x10\x17\x12\x12\n" +
	"\x0eFILE_CHUNK_ACK\x10\x18\x12\x11\n" +
	"\rFILE_COMPLETE\x10\x19\x12\x0f\n" +
	"\vFILE_CANCEL\x10\x1a\x12\x11\n" +
	"\rDHT_FIND_NODE\x10\x1e\x12\x15\n" +
	"\x11DHT_NODE_RESPONSE\x10\x1f\x12\x12\n" +
	"\x0eDHT_PUT_RECORD\x10 \x12\b\n" +
	"\x04PING\x10(\x12\b\n" +
	"\x04PONG\x10)B1Z/github.com/boxsie/ensemble/internal/protocol/pbb\x06proto3"

var (
	file_messages_proto_rawDescOnce sync.Once
	file_messages_proto_rawDescData []byte
)

func file_messages_proto_rawDescGZIP() []byte {
	file_messages_proto_rawDescOnce.Do(func() {
		file_messages_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_messages_proto_rawDesc), len(file_messages_proto_rawDesc)))
	})
	return file_messages_proto_rawDescData
}

var file_messages_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_messages_proto_msgTypes = make([]protoimpl.MessageInfo, 21)
var file_messages_proto_goTypes = []any{
	(MessageType)(0),        // 0: ensemble.protocol.MessageType
	(*Envelope)(nil),        // 1: ensemble.protocol.Envelope
	(*ConnRequest)(nil),     // 2: ensemble.protocol.ConnRequest
	(*ConnResponse)(nil),    // 3: ensemble.protocol.ConnResponse
	(*ConnConfirm)(nil),     // 4: ensemble.protocol.ConnConfirm
	(*IPExchangeMsg)(nil),   // 5: ensemble.protocol.IPExchangeMsg
	(*ChatText)(nil),        // 6: ensemble.protocol.ChatText
	(*ChatAck)(nil),         // 7: ensemble.protocol.ChatAck
	(*ChatTyping)(nil),      // 8: ensemble.protocol.ChatTyping
	(*FileOffer)(nil),       // 9: ensemble.protocol.FileOffer
	(*FileAccept)(nil),      // 10: ensemble.protocol.FileAccept
	(*FileReject)(nil),      // 11: ensemble.protocol.FileReject
	(*FileChunk)(nil),       // 12: ensemble.protocol.FileChunk
	(*FileChunkAck)(nil),    // 13: ensemble.protocol.FileChunkAck
	(*FileComplete)(nil),    // 14: ensemble.protocol.FileComplete
	(*FileCancel)(nil),      // 15: ensemble.protocol.FileCancel
	(*DHTFindNode)(nil),     // 16: ensemble.protocol.DHTFindNode
	(*DHTNodeResponse)(nil), // 17: ensemble.protocol.DHTNodeResponse
	(*DHTPutRecord)(nil),    // 18: ensemble.protocol.DHTPutRecord
	(*PeerRecord)(nil),      // 19: ensemble.protocol.PeerRecord
	(*Ping)(nil),            // 20: ensemble.protocol.Ping
	(*Pong)(nil),            // 21: ensemble.protocol.Pong
}
var file_messages_proto_depIdxs = []int32{
	0,  // 0: ensemble.protocol.Envelope.type:type_name -> ensemble.protocol.MessageType
	19, // 1: ensemble.protocol.DHTNodeResponse.peers:type_name -> ensemble.protocol.PeerRecord
	19, // 2: ensemble.protocol.DHTPutRecord.record:type_name -> ensemble.protocol.PeerRecord
	3,  // [3:3] is the sub-list for method output_type
	3,  // [3:3] is the sub-list for method input_type
	3,  // [3:3] is the sub-list for extension type_name
	3,  // [3:3] is the sub-list for extension extendee
	0,  // [0:3] is the sub-list for field type_name
}

func init() { file_messages_proto_init() }
func file_messages_proto_init() {
	if File_messages_proto != nil {
		return
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_messages_proto_rawDesc), len(file_messages_proto_rawDesc)),
			NumEnums:      1,
			NumMessages:   21,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_messages_proto_goTypes,
		DependencyIndexes: file_messages_proto_depIdxs,
		EnumInfos:         file_messages_proto_enumTypes,
		MessageInfos:      file_messages_proto_msgTypes,
	}.Build()
	File_messages_proto = out.File
	file_messages_proto_goTypes = nil
	file_messages_proto_depIdxs = nil
}
